// const mongoose = require('mongoose');

// const ConsentSchema = new mongoose.Schema({
//   source: { type: String },        // who gave consent / metadata owner
//   consent: { type: Boolean, default: false },
//   timestamp: { type: Date },
//   meta: { type: mongoose.Schema.Types.Mixed }
// }, { _id: false });

// const BundleSchema = new mongoose.Schema({
//   abhaId: { type: String, required: true, index: true },
//   encounterDetail: { type: mongoose.Schema.Types.Mixed, required: true },
//   problemList: { type: [mongoose.Schema.Types.Mixed], default: [] },
//   namaste_code: { type: String, default: '' },
//   icd_tm2_code: { type: String, default: '' },
//   consentMetaData: { type: [ConsentSchema], default: [] },
//   createdAt: { type: Date, default: () => new Date() },
//   rawPayload: { type: mongoose.Schema.Types.Mixed }
// }, {
//   collection: 'bundles'
// });

// module.exports = mongoose.model('Bundle', BundleSchema, 'bundles');


const mongoose = require('mongoose');
const { ObjectId } = mongoose.Schema.Types;

const ConsentSchema = new mongoose.Schema({
  consentId: { type: ObjectId },          // auto-generated by hook
  source: { type: String },
  consent: { type: Boolean, default: false },
  timestamp: { type: Date },
  meta: { type: mongoose.Schema.Types.Mixed }
}, { _id: false });

const BundleSchema = new mongoose.Schema({
  abhaId: { type: String, required: true, index: true },
  encounterDetail: {
    encounterId: { type: ObjectId },      // auto-generated by hook
    type: mongoose.Schema.Types.Mixed
  },
  problemList: { type: [mongoose.Schema.Types.Mixed], default: [] },
  namaste_code: { type: String, default: '' },
  icd_tm2_code: { type: String, default: '' },
  consentMetaData: { type: [ConsentSchema], default: [] },
  createdAt: { type: Date, default: () => new Date() },
  rawPayload: { type: mongoose.Schema.Types.Mixed }
}, {
  collection: 'bundles'
});

// Auto-generate ObjectIds where missing
BundleSchema.pre('validate', function (next) {
  if (!this.encounterDetail) this.encounterDetail = {};

  // Auto-generate encounterId
  if (!this.encounterDetail.encounterId) {
    this.encounterDetail.encounterId = new mongoose.Types.ObjectId();
  }

  // Auto-generate consentId for each consent entry
  if (Array.isArray(this.consentMetaData)) {
    this.consentMetaData.forEach(c => {
      if (!c.consentId) c.consentId = new mongoose.Types.ObjectId();
      if (!c.timestamp) c.timestamp = new Date();
    });
  }

  next();
});

module.exports = mongoose.model('Bundle', BundleSchema, 'bundles');
